---
title: 深拷贝和浅拷贝
conmment: true
customerLayoutList: true
---

本文主要讲一下js的基础数据类型以及一些堆和栈的知识，还有什么是深拷贝，什么是浅拷贝，两者的区别，以及怎么实现深拷贝和浅拷贝。

### 堆和栈的区别

其实深拷贝和浅拷贝的主要区别就是在内存中的存储类型不同。

堆和栈都是内存中划分出来用来存储的区域。

> 栈为自动分配的内存空间，它由系统自动释放；而堆则是动态分配的内存，大小不定也不会自动释放。

### ECMAScript的数据类型

> 基本数据类型：undefined, null, number, boolean, string。 ES6新增Symbol

#### 基本数据类型存放在栈中

存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配，是直接按值存放的，所以，可以直接访问。

#### 基本数据类型的值不可改变

> js中的原始值与对象有着根本的区别。原始值是不可更改的：任何方法都无法更改一个原始值。对数字和布尔值来说显然如此 —— 改变数字的值本身就说不通，而对字符串来说就不那么明显了，因为字符串看起来像由字符组成的数组，我们期望可以通过指定索引来假改字符串中的字符。实际上，javascript 是禁止这样做的。字符串中所有的方法看上去返回了一个修改后的字符串，实际上返回的是一个新的字符串值。

基本数据类型是不可变的，动态修改了基本数据类型的值，它的原始值也是不会改变的，例如：

``` js
var str = 'abc';

console.log(str[1] = 'f'); //f
console.log(str); // abc
```

我们通常情况下都是对一个变量重新赋值，而不是改变基本数据类型的值。就如上述引用所说的那样，在js中没有方法是可以改变布尔值和数字的。倒是有很多操作字符串的方法，但是这些方法**都是返回一个新的字符串**，并没有改变其原有的数据。

所以，记住一点：**基本数据类型的值不可变**。

#### 基本类型的比较是值的比较

基本类型的比较是值的比较，只要它们的值相等就认为他们是相等的，例如：

``` js
  var a = 1;
  var b = 1;
  
  console.log(a === b) // true
```

比较的时候最好使用 **===**，因为 **==** 是会进行类型转换的，例如：

``` js
 var a = 1;
 var b = true;

 console.log(a == b) // true
 console.log(a === b) // false
```

关于js类型转换可去看[JavaScript 类型转换](https://www.qinshenxue.com/article/javascript-type-conversion.html)

### 引用类型

#### 引用类型存放在堆中

引用类型是存放在堆内存中的，变量实际上是一个存放在栈内存的指针，这个指针指向堆内存中的地址。例如

``` js
const p1 = {name: '张三'};
const p2 = {name: '李四'};
const p3 = {name: '王五'}
```

```
-----------------        ---------------- 
|      栈区      |       |      堆区      |
-----------------        ---------------- 
|  p1   | 堆地址 |  =>   |  {name: '张三'} |  
|  p2   | 堆地址 |  =>   |  {name: '李四'} |
|  p3   | 堆地址 |  =>   |  {name: '王五'} |
-----------------        ----------------
```

#### 引用类型值可变

引用类型的值是可变的，例如：

```js
const a = [1, 2, 3];
a[2] = 4;
console.log(a); // [1, 2, 4];
```

#### 引用类型的比较是引用的比较

每次我们对js中的引用类型进行操作的试试，都是操作其对象的引用(保存在栈内存中的指针)，所以比较两个引用类型，是看其引用类型是否指向同一个对象。

``` js
const a = [1,2,3];
const b = [1,2,3];
console.log(a === b); // false
```

变量a和b都是一个内容为[1,2,3]的数组，但是他们在内存中的位置不一样，指向的不是同一个对象，所以不相等。

### 传值与传地址

了解了基本数据类型与引用类型的区别之后，我们就应该能明白传值与传址的区别了。
在我们进行赋值操作的时候，基本数据类型的赋值（=）是在内存中新开辟一段栈内存，然后再把再将值赋值到新的栈中。例如：

``` js
var a = 10;
var b = a;

a++;

console.log(a) // 11
console.log(b) // 10
```

所以说，基本类型的赋值的两个变量是两个独立相互不影响的变量。

但是引用类型的赋值是传址。只是改变指针的指向，例如，也就是说引用类型的赋值是对象保存在栈中的地址的赋值，这样的话两个变量就指向同一个对象，因此两者之间操作互相有影响。例如：

``` js
const a ={};
const b = a;

a.name = '张三';
console.log(a.name) // 张三
console.log(b.name) // 张三

b.age = 18;
console.log(a.age) // 18
console.log(b.age) // 18
```

### 浅拷贝

#### 赋值(=)和浅拷贝的区别

赋值 例子：
``` js
var o1 = {
  name: '张三',
  language: [1, [1,2]]
}

var o2 = o1;

o2.name = '李四';
o2.language[1] = ['一'];

console.log(o1); // {name: '李四', language: [1, '一']}
console.log(o2); // {name: '李四', language: [1, '一']}
```

浅拷贝 例子：

``` js
var o1 = {
  name: '张三',
  language: [1, [1,2]]
}

var o3 = clone(o1);

function clone(obj) {
  const newObj = {};
  for (let i in obj) {
    if (obj.hasOwnProperty(i)) {
      newObj[i] = obj[i];
    }
  }
  return newObj;
}

o3.name = '王五';
o3.language[1] = ['一'];

console.log(o1); // {name: '张三', language: [1, '一']}
console.log(o3); // {name: '王五', language: [1, '一']}
```

通过上述例子看到:

1. 改变name属性,o2和o3的结果不一样，赋值操作o2中name的改变会影响到o1。而浅拷贝o3中name的改变则不会改变原始对象o1。
2. 改变language属性，o2和o3的结果一样。

这是因为浅拷贝值赋值一层对象的属性，并不包含对象里面的引用类型的数据，所以，就会出现改变浅拷贝得到的o3中的引用类型时，会使原始数据得到改变。

所以，深拷贝和浅拷贝的区别就是：

**深拷贝：将A对象拷贝到B对象中，包括A里面的子对象。**
**浅拷贝：将A对象拷贝到B对象中，但不包括A里面的子对象。**

